<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ùÑÔ∏èü¶ã Realistic Particles - Snowflake & Butterfly</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Arial', sans-serif; background: #000; overflow: hidden; }
        #canvas-container { width: 100vw; height: 100vh; position: relative; }
        
        #controls {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.95); padding: 25px;
            border-radius: 20px; color: white; max-width: 380px;
            backdrop-filter: blur(25px); z-index: 100;
            max-height: 90vh; overflow-y: auto;
            border: 2px solid rgba(0, 255, 200, 0.5);
            box-shadow: 0 15px 60px rgba(0, 255, 200, 0.4);
        }
        
        h1 {
            font-size: 24px;
            background: linear-gradient(135deg, #e0f7ff, #00ffaa, #ffdd00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px; text-align: center;
            font-weight: bold; letter-spacing: 1px;
        }
        
        .mode-switch {
            display: grid; grid-template-columns: 1fr 1fr;
            gap: 12px; margin-bottom: 25px;
        }
        
        .mode-btn {
            padding: 18px 12px; font-size: 14px;
            background: rgba(0, 255, 200, 0.1);
            border: 2px solid rgba(0, 255, 200, 0.3);
            border-radius: 12px; color: white;
            cursor: pointer; transition: all 0.3s;
            font-weight: bold; text-align: center;
        }
        
        .mode-btn:hover { background: rgba(0, 255, 200, 0.2); transform: scale(1.05); }
        .mode-btn.active {
            background: linear-gradient(135deg, rgba(0, 255, 200, 0.4), rgba(0, 191, 255, 0.4));
            border-color: #00ffaa;
            box-shadow: 0 0 30px rgba(0, 255, 200, 0.6);
        }
        
        h2 {
            font-size: 14px; margin: 25px 0 15px 0; color: #00ffaa;
            border-bottom: 2px solid rgba(0, 255, 200, 0.4);
            padding-bottom: 8px; text-transform: uppercase;
        }
        
        .control-group { margin-bottom: 18px; }
        
        label {
            display: block; margin-bottom: 8px;
            font-size: 12px; color: #ccc; font-weight: 500;
        }
        
        input[type="color"], input[type="range"] {
            width: 100%; padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px; background: rgba(255, 255, 255, 0.05);
            color: white; cursor: pointer; transition: all 0.3s;
        }
        
        input[type="range"]:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(0, 255, 200, 0.3);
        }
        
        input[type="color"] { height: 55px; cursor: pointer; }
        input[type="range"] { padding: 0; height: 6px; }
        
        button {
            width: 100%; padding: 16px; margin-top: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none; border-radius: 12px; color: white;
            font-weight: bold; cursor: pointer; transition: all 0.3s;
            font-size: 14px;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.6);
        }
        
        .info {
            position: absolute; bottom: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.95); padding: 20px;
            border-radius: 15px; color: white; font-size: 13px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 255, 200, 0.3);
            line-height: 2;
        }
        
        .badge {
            display: inline-block; padding: 5px 12px;
            background: linear-gradient(135deg, rgba(0, 255, 200, 0.3), rgba(255, 221, 0, 0.3));
            border-radius: 15px; font-size: 11px;
            margin-top: 10px; color: #fff;
            font-weight: bold; letter-spacing: 0.5px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls">
        <h1>‚ú® Realistic Particles</h1>
        
        <div class="mode-switch">
            <button class="mode-btn active" data-mode="snowflake">
                ‚ùÑÔ∏è<br><strong>Snowflake</strong><br><small>ÂÖ≠ËßíÂÜ∞Êô∂</small>
            </button>
            <button class="mode-btn" data-mode="butterfly">
                ü¶ã<br><strong>Butterfly</strong><br><small>Ëù¥Ëù∂È£ûËàû</small>
            </button>
        </div>
        
        <h2>‚öôÔ∏è Parameters</h2>
        
        <div class="control-group">
            <label>Color Palette</label>
            <input type="color" id="color-picker" value="#e8f4ff">
        </div>
        
        <div class="control-group">
            <label>Particles: <span id="count-value">15000</span></label>
            <input type="range" id="particle-count" min="5000" max="30000" value="15000" step="2500">
        </div>
        
        <div class="control-group">
            <label>Size: <span id="size-value">1.0</span></label>
            <input type="range" id="particle-size" min="0.5" max="3.0" value="1.0" step="0.1">
        </div>
        
        <div class="control-group">
            <label>Speed: <span id="speed-value">0.04</span></label>
            <input type="range" id="particle-speed" min="0.01" max="0.3" value="0.04" step="0.01">
        </div>
        
        <div class="control-group">
            <label>Rotation: <span id="rotation-value">0.5</span></label>
            <input type="range" id="rotation-speed" min="0.0" max="2.0" value="0.5" step="0.1">
        </div>
        
        <div class="control-group">
            <label>Sparkle: <span id="sparkle-value">1.5</span></label>
            <input type="range" id="sparkle-intensity" min="0.5" max="3.0" value="1.5" step="0.1">
        </div>
        
        <button id="screenshot" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">
            üì∏ Take Screenshot
        </button>
        <button id="reset" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
            üîÑ Reset Camera
        </button>
    </div>
    
    <div class="info">
        <div>üñ±Ô∏è <strong>Drag</strong> to rotate view</div>
        <div>üîç <strong>Scroll</strong> to zoom in/out</div>
        <div>‚ö° <strong>Auto-rotate</strong> enabled</div>
        <div class="badge">REALISTIC SHADERS</div>
    </div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        console.log('‚ùÑÔ∏èü¶ã Realistic Particle System Loading...');
        
        // === REALISTIC SNOWFLAKE SHADER ===
        const snowflakeVertexShader = `
            attribute float size;
            attribute float rotation;
            attribute float sparkle;
            varying float vRotation;
            varying float vSparkle;
            varying vec3 vPosition;
            uniform float time;
            
            void main() {
                vRotation = rotation + time * 0.2;
                vSparkle = sparkle;
                vPosition = position;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * (500.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;
        
        const snowflakeFragmentShader = `
            uniform vec3 color;
            uniform float sparkleIntensity;
            uniform float time;
            varying float vRotation;
            varying float vSparkle;
            varying vec3 vPosition;
            
            #define PI 3.14159265359
            
            // ÂÖ≠ËæπÂΩ¢Ë∑ùÁ¶ªÂáΩÊï∞
            float hexagonSDF(vec2 p, float r) {
                const vec3 k = vec3(-0.866025404, 0.5, 0.577350269);
                p = abs(p);
                p -= 2.0 * min(dot(k.xy, p), 0.0) * k.xy;
                p -= vec2(clamp(p.x, -k.z * r, k.z * r), r);
                return length(p) * sign(p.y);
            }
            
            // Èõ™Ëä±ÂΩ¢Áä∂ - ÂÖ≠ËßíÊòü + ÂàÜÊîØ
            float snowflakeShape(vec2 p) {
                float angle = atan(p.y, p.x);
                float r = length(p);
                
                // 6‰∏™ÂØπÁß∞ËΩ¥
                float a6 = mod(angle, PI / 3.0) - PI / 6.0;
                vec2 p6 = vec2(cos(a6), sin(a6)) * r;
                
                // ‰∏ªËΩ¥ (6Êù°)
                float mainArm = 1.0 - smoothstep(0.02, 0.04, abs(p6.y));
                mainArm *= smoothstep(0.9, 0.85, r);
                
                // ÂàÜÊîØ (Á¨¨1Â±Ç)
                float branch1 = 1.0 - smoothstep(0.01, 0.02, abs(p6.y - 0.15));
                branch1 *= smoothstep(0.7, 0.65, r) * smoothstep(0.3, 0.35, r);
                
                // ÂàÜÊîØ (Á¨¨2Â±Ç)
                float branch2 = 1.0 - smoothstep(0.01, 0.02, abs(p6.y - 0.25));
                branch2 *= smoothstep(0.55, 0.5, r) * smoothstep(0.2, 0.25, r);
                
                // ÂÖ≠ËæπÂΩ¢Ê†∏ÂøÉ
                float hex = hexagonSDF(p, 0.15);
                float core = 1.0 - smoothstep(-0.02, 0.02, hex);
                
                // ÂÖ≠ËæπÂΩ¢Â§ñÁéØ
                float hex2 = hexagonSDF(p, 0.35);
                float ring = (1.0 - smoothstep(-0.02, 0.0, hex2)) * smoothstep(0.0, 0.02, hex2);
                
                return clamp(core + ring * 0.8 + mainArm * 0.9 + branch1 * 0.7 + branch2 * 0.6, 0.0, 1.0);
            }
            
            // ÂÜ∞Êô∂ÊäòÂ∞ÑÊïàÊûú
            vec3 prismEffect(vec3 baseColor, float angle, float intensity) {
                vec3 rainbow = vec3(
                    sin(angle * 3.0 + time * 2.0) * 0.5 + 0.5,
                    sin(angle * 3.0 + time * 2.0 + 2.094) * 0.5 + 0.5,
                    sin(angle * 3.0 + time * 2.0 + 4.189) * 0.5 + 0.5
                );
                return mix(baseColor, rainbow * 1.5, intensity * 0.3);
            }
            
            void main() {
                vec2 uv = (gl_PointCoord - 0.5) * 2.0;
                
                // ÊóãËΩ¨
                float c = cos(vRotation);
                float s = sin(vRotation);
                uv = mat2(c, -s, s, c) * uv;
                
                // Èõ™Ëä±ÂΩ¢Áä∂
                float shape = snowflakeShape(uv);
                
                // Èó™ÁÉÅÊïàÊûú
                float sparkleAnim = sin(time * 6.0 + vSparkle * 12.0 + vPosition.y * 0.5) * 0.4 + 0.6;
                sparkleAnim = pow(sparkleAnim, 3.0) * sparkleIntensity;
                
                // ÂÜ∞Êô∂ÊäòÂ∞Ñ
                float angle = atan(uv.y, uv.x);
                vec3 finalColor = prismEffect(color, angle, sparkleAnim);
                
                // ‰∏≠ÂøÉÂà∞ËæπÁºòÁöÑÈÄèÊòéÂ∫¶Ê∏êÂèò
                float dist = length(uv);
                float centerGlow = 1.0 - smoothstep(0.0, 0.3, dist);
                finalColor += vec3(1.0) * centerGlow * 0.3 * sparkleAnim;
                
                // ÊúÄÁªàÈÄèÊòéÂ∫¶
                float alpha = shape * (0.85 + sparkleAnim * 0.15);
                
                gl_FragColor = vec4(finalColor, alpha);
            }
        `;
        
        // === REALISTIC BUTTERFLY SHADER ===
        const butterflyVertexShader = `
            attribute float size;
            attribute float phase;
            attribute float wingAngle;
            varying float vPhase;
            varying float vWingAngle;
            varying vec3 vPosition;
            uniform float time;
            
            void main() {
                vPhase = phase;
                vWingAngle = wingAngle;
                vPosition = position;
                
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * (600.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;
        
        const butterflyFragmentShader = `
            uniform vec3 color;
            uniform float time;
            varying float vPhase;
            varying float vWingAngle;
            varying vec3 vPosition;
            
            #define PI 3.14159265359
            
            // ÁøÖËÜÄÂΩ¢Áä∂
            float wingShape(vec2 p, float side) {
                // Ê§≠ÂúÜÂΩ¢ÁøÖËÜÄËΩÆÂªì
                p.x *= 0.6; // ÂÆΩÂ∫¶
                p.y *= 1.2; // È´òÂ∫¶
                float wing = length(p);
                
                // ÁøÖËÜÄËæπÁºò
                float edge = smoothstep(0.9, 0.85, wing) * smoothstep(0.2, 0.25, wing);
                
                return edge;
            }
            
            // ÁøÖËÜÄËä±Á∫π
            float wingPattern(vec2 p) {
                // ÊñëÁÇπ
                float spot1 = 1.0 - smoothstep(0.08, 0.12, length(p - vec2(0.3, 0.2)));
                float spot2 = 1.0 - smoothstep(0.06, 0.10, length(p - vec2(0.5, -0.1)));
                float spot3 = 1.0 - smoothstep(0.05, 0.08, length(p - vec2(0.2, -0.3)));
                
                // Êù°Á∫π
                float stripe = sin(p.y * 8.0 + p.x * 3.0) * 0.5 + 0.5;
                stripe = smoothstep(0.4, 0.6, stripe) * 0.3;
                
                return spot1 * 0.8 + spot2 * 0.6 + spot3 * 0.5 + stripe;
            }
            
            void main() {
                vec2 uv = (gl_PointCoord - 0.5) * 2.0;
                
                // ÊãçÊâìÂä®Áîª
                float flapTime = time * 6.0 + vPhase * 10.0;
                float flap = sin(flapTime);
                float flapAngle = flap * 0.4; // ¬±23Â∫¶
                
                // Â∑¶Âè≥ÁøÖËÜÄ
                float leftWing = 0.0;
                float rightWing = 0.0;
                
                if (uv.x < 0.0) {
                    // Â∑¶ÁøÖËÜÄ
                    vec2 pLeft = uv;
                    pLeft.x = -pLeft.x; // ÈïúÂÉè
                    float angle = flapAngle;
                    pLeft = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * pLeft;
                    leftWing = wingShape(pLeft, -1.0);
                    leftWing *= (1.0 + wingPattern(pLeft) * 0.5);
                } else {
                    // Âè≥ÁøÖËÜÄ
                    vec2 pRight = uv;
                    float angle = -flapAngle;
                    pRight = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * pRight;
                    rightWing = wingShape(pRight, 1.0);
                    rightWing *= (1.0 + wingPattern(pRight) * 0.5);
                }
                
                float wing = max(leftWing, rightWing);
                
                // Ë∫´‰ΩìÔºà‰∏≠ÂøÉÁ∫øÔºâ
                float body = 1.0 - smoothstep(0.02, 0.05, abs(uv.x));
                body *= smoothstep(0.8, 0.7, abs(uv.y));
                
                // È¢úËâ≤Ê∏êÂèòÔºàÊ†πÈÉ®Âà∞ËæπÁºòÔºâ
                float dist = length(uv);
                vec3 darkColor = color * 0.5;
                vec3 lightColor = color * 1.3;
                vec3 finalColor = mix(darkColor, lightColor, dist * 0.8);
                
                // ÁøÖËÜÄÂÖâÊ≥Ω
                float shine = pow(1.0 - dist, 3.0) * 0.4;
                finalColor += vec3(shine);
                
                // ÊúÄÁªàÂêàÊàê
                float alpha = clamp(wing + body * 0.9, 0.0, 1.0);
                
                gl_FragColor = vec4(finalColor, alpha);
            }
        `;
        
        // === CONFIG ===
        const configs = {
            snowflake: {
                type: 'snowflake',
                count: 15000,
                color: '#e8f4ff',
                size: 1.0,
                speed: 0.04,
                rotation: 0.5,
                sparkle: 1.5
            },
            butterfly: {
                type: 'butterfly',
                count: 600,
                color: '#ffdd00',
                size: 2.5,
                speed: 0.08,
                rotation: 0.3,
                sparkle: 1.0
            }
        };
        
        let scene, camera, renderer, controls, particles = null, backgroundStars = null;
        let currentConfig = { ...configs.snowflake };
        let time = 0;
        
        function init() {
            scene = new THREE.Scene();
            createCosmicBackground();
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 25);
            
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, alpha: false, powerPreference: 'high-performance'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 12;
            controls.maxDistance = 60;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;
            controls.maxPolarAngle = Math.PI * 0.7;
            
            scene.add(new THREE.AmbientLight(0xffffff, 1.8));
            const light1 = new THREE.PointLight(0x00ffaa, 3, 100);
            light1.position.set(20, 20, 20);
            scene.add(light1);
            const light2 = new THREE.PointLight(0x0088ff, 2.5, 100);
            light2.position.set(-20, -15, 15);
            scene.add(light2);
            
            createParticles();
            setupControls();
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            animate();
            console.log('‚úÖ Realistic System Ready!');
        }
        
        function createCosmicBackground() {
            const canvas = document.createElement('canvas');
            canvas.width = 4; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#001428');
            gradient.addColorStop(0.4, '#002855');
            gradient.addColorStop(0.7, '#003e72');
            gradient.addColorStop(1, '#000000');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 4, 512);
            scene.background = new THREE.CanvasTexture(canvas);
            
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 6000;
            const starPositions = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                const radius = 180 + Math.random() * 400;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                starPositions[i3 + 2] = radius * Math.cos(phi);
            }
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff, size: 1.2, sizeAttenuation: true,
                transparent: true, opacity: 0.95, blending: THREE.AdditiveBlending
            });
            backgroundStars = new THREE.Points(starGeometry, starMaterial);
            scene.add(backgroundStars);
        }
        
        function createParticles() {
            if (particles) {
                scene.remove(particles);
                particles.geometry.dispose();
                particles.material.dispose();
            }
            
            const count = currentConfig.count;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const velocities = new Float32Array(count * 3);
            const phases = new Float32Array(count);
            const sizes = new Float32Array(count);
            const rotations = new Float32Array(count);
            const sparkles = new Float32Array(count);
            const wingAngles = new Float32Array(count);
            
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 35;
                positions[i3 + 1] = (Math.random() - 0.5) * 35;
                positions[i3 + 2] = (Math.random() - 0.5) * 35;
                
                velocities[i3] = (Math.random() - 0.5) * 0.4;
                velocities[i3 + 1] = (Math.random() - 0.5) * 0.4;
                velocities[i3 + 2] = (Math.random() - 0.5) * 0.4;
                
                phases[i] = Math.random() * Math.PI * 2;
                sizes[i] = (Math.random() * 0.7 + 0.6) * currentConfig.size;
                rotations[i] = Math.random() * Math.PI * 2;
                sparkles[i] = Math.random();
                wingAngles[i] = Math.random() * Math.PI;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('rotation', new THREE.BufferAttribute(rotations, 1));
            geometry.setAttribute('sparkle', new THREE.BufferAttribute(sparkles, 1));
            geometry.setAttribute('wingAngle', new THREE.BufferAttribute(wingAngles, 1));
            
            let material;
            const color = new THREE.Color(currentConfig.color);
            
            if (currentConfig.type === 'snowflake') {
                material = new THREE.ShaderMaterial({
                    uniforms: {
                        color: { value: color },
                        time: { value: 0 },
                        sparkleIntensity: { value: currentConfig.sparkle }
                    },
                    vertexShader: snowflakeVertexShader,
                    fragmentShader: snowflakeFragmentShader,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
            } else {
                material = new THREE.ShaderMaterial({
                    uniforms: {
                        color: { value: color },
                        time: { value: 0 }
                    },
                    vertexShader: butterflyVertexShader,
                    fragmentShader: butterflyFragmentShader,
                    transparent: true,
                    depthWrite: false
                });
            }
            
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            console.log(`‚úÖ ${count} ${currentConfig.type} particles`);
        }
        
        function updateParticles() {
            if (!particles) return;
            time += 0.016;
            
            if (particles.material.uniforms) {
                particles.material.uniforms.time.value = time;
                if (particles.material.uniforms.sparkleIntensity) {
                    particles.material.uniforms.sparkleIntensity.value = currentConfig.sparkle;
                }
            }
            
            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.geometry.attributes.velocity.array;
            const phases = particles.geometry.attributes.phase.array;
            const rotations = particles.geometry.attributes.rotation.array;
            const speed = currentConfig.speed;
            const rotSpeed = currentConfig.rotation;
            
            for (let i = 0; i < positions.length; i += 3) {
                const idx = i / 3;
                const phase = phases[idx];
                
                if (currentConfig.type === 'snowflake') {
                    // Èõ™Ëä±: ‰∏ãËêΩ + ÊóãËΩ¨ + È£òÂä®
                    positions[i + 1] -= speed;
                    positions[i] += Math.sin(time * 1.5 + phase) * 0.008;
                    positions[i + 2] += Math.cos(time * 1.2 + phase) * 0.006;
                    
                    // ÊóãËΩ¨
                    rotations[idx] += rotSpeed * 0.01;
                    
                    if (positions[i + 1] < -18) {
                        positions[i + 1] = 18;
                        positions[i] = (Math.random() - 0.5) * 35;
                        positions[i + 2] = (Math.random() - 0.5) * 35;
                    }
                } else {
                    // Ëù¥Ëù∂: Ê≥¢Êµ™È£ûË°å
                    const waveX = Math.sin(time * 1.5 + phase) * 0.15;
                    const waveY = Math.sin(time * 2.0 + phase * 1.3) * 0.1 + Math.cos(time * 1.2) * 0.05;
                    const waveZ = Math.cos(time * 1.8 + phase) * 0.15;
                    
                    positions[i] += (velocities[i] * speed * 2 + waveX);
                    positions[i + 1] += waveY;
                    positions[i + 2] += (velocities[i + 2] * speed * 2 + waveZ);
                    
                    // ËæπÁïåÊ£ÄÊü•
                    if (Math.abs(positions[i]) > 20) velocities[i] *= -1;
                    if (Math.abs(positions[i + 1]) > 15) velocities[i + 1] *= -1;
                    if (Math.abs(positions[i + 2]) > 20) velocities[i + 2] *= -1;
                }
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            if (currentConfig.type === 'snowflake') {
                particles.geometry.attributes.rotation.needsUpdate = true;
            }
            
            if (backgroundStars) backgroundStars.rotation.y += 0.0003;
        }
        
        function setupControls() {
            const modeBtns = document.querySelectorAll('.mode-btn');
            modeBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    modeBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    const mode = btn.dataset.mode;
                    currentConfig = { ...configs[mode] };
                    
                    document.getElementById('color-picker').value = currentConfig.color;
                    document.getElementById('particle-count').value = currentConfig.count;
                    document.getElementById('particle-size').value = currentConfig.size;
                    document.getElementById('particle-speed').value = currentConfig.speed;
                    document.getElementById('rotation-speed').value = currentConfig.rotation;
                    document.getElementById('sparkle-intensity').value = currentConfig.sparkle;
                    
                    document.getElementById('count-value').textContent = currentConfig.count;
                    document.getElementById('size-value').textContent = currentConfig.size;
                    document.getElementById('speed-value').textContent = currentConfig.speed;
                    document.getElementById('rotation-value').textContent = currentConfig.rotation;
                    document.getElementById('sparkle-value').textContent = currentConfig.sparkle;
                    
                    createParticles();
                });
            });
            
            document.getElementById('color-picker').addEventListener('input', (e) => {
                currentConfig.color = e.target.value;
                const newColor = new THREE.Color(e.target.value);
                if (particles.material.uniforms?.color) {
                    particles.material.uniforms.color.value = newColor;
                }
            });
            
            document.getElementById('particle-count').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                document.getElementById('count-value').textContent = value;
                currentConfig.count = value;
                createParticles();
            });
            
            document.getElementById('particle-size').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('size-value').textContent = value;
                currentConfig.size = value;
            });
            
            document.getElementById('particle-speed').addEventListener('input', (e) => {
                document.getElementById('speed-value').textContent = e.target.value;
                currentConfig.speed = parseFloat(e.target.value);
            });
            
            document.getElementById('rotation-speed').addEventListener('input', (e) => {
                document.getElementById('rotation-value').textContent = e.target.value;
                currentConfig.rotation = parseFloat(e.target.value);
            });
            
            document.getElementById('sparkle-intensity').addEventListener('input', (e) => {
                document.getElementById('sparkle-value').textContent = e.target.value;
                currentConfig.sparkle = parseFloat(e.target.value);
            });
            
            document.getElementById('screenshot').addEventListener('click', () => {
                renderer.render(scene, camera);
                renderer.domElement.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `realistic-${currentConfig.type}-${Date.now()}.png`;
                    link.click();
                    URL.revokeObjectURL(url);
                });
            });
            
            document.getElementById('reset').addEventListener('click', () => {
                camera.position.set(0, 5, 25);
                controls.target.set(0, 0, 0);
                controls.update();
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateParticles();
            renderer.render(scene, camera);
        }
        
        init();
        console.log('üéâ Realistic Snowflake & Butterfly System Active!');
    </script>
</body>
</html>