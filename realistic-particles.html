<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚≠ê Realistic Particles v2.0</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Arial', sans-serif; background: #000; overflow: hidden; }
        #canvas-container { width: 100vw; height: 100vh; position: relative; }
        
        #controls {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.95); padding: 25px;
            border-radius: 20px; color: white; max-width: 400px;
            backdrop-filter: blur(25px); z-index: 100;
            max-height: 90vh; overflow-y: auto;
            border: 2px solid rgba(0, 255, 200, 0.5);
            box-shadow: 0 15px 60px rgba(0, 255, 200, 0.4);
        }
        
        h1 {
            font-size: 26px;
            background: linear-gradient(135deg, #e0f7ff, #00ffaa, #ffdd00, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px; text-align: center;
            font-weight: bold; letter-spacing: 1.5px;
        }
        
        .mode-grid {
            display: grid; grid-template-columns: repeat(2, 1fr);
            gap: 10px; margin-bottom: 25px;
        }
        
        .mode-btn {
            padding: 15px 10px; font-size: 13px;
            background: rgba(0, 255, 200, 0.08);
            border: 2px solid rgba(0, 255, 200, 0.25);
            border-radius: 12px; color: white;
            cursor: pointer; transition: all 0.3s;
            font-weight: bold; text-align: center;
            line-height: 1.4;
        }
        
        .mode-btn:hover { 
            background: rgba(0, 255, 200, 0.15); 
            transform: scale(1.05);
            border-color: rgba(0, 255, 200, 0.4);
        }
        
        .mode-btn.active {
            background: linear-gradient(135deg, rgba(0, 255, 200, 0.35), rgba(0, 191, 255, 0.35));
            border-color: #00ffaa;
            box-shadow: 0 0 30px rgba(0, 255, 200, 0.6);
            transform: scale(1.05);
        }
        
        h2 {
            font-size: 14px; margin: 25px 0 15px 0; color: #00ffaa;
            border-bottom: 2px solid rgba(0, 255, 200, 0.4);
            padding-bottom: 8px; text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .control-group { margin-bottom: 18px; }
        
        label {
            display: block; margin-bottom: 8px;
            font-size: 12px; color: #ccc; font-weight: 500;
        }
        
        input[type="color"], input[type="range"] {
            width: 100%; padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px; background: rgba(255, 255, 255, 0.05);
            color: white; cursor: pointer; transition: all 0.3s;
        }
        
        input[type="range"]:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(0, 255, 200, 0.3);
        }
        
        input[type="color"] { height: 55px; }
        input[type="range"] { padding: 0; height: 6px; }
        
        button {
            width: 100%; padding: 16px; margin-top: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none; border-radius: 12px; color: white;
            font-weight: bold; cursor: pointer; transition: all 0.3s;
            font-size: 14px;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.6);
        }
        
        .info {
            position: absolute; bottom: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.95); padding: 20px;
            border-radius: 15px; color: white; font-size: 13px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 255, 200, 0.3);
            line-height: 2;
        }
        
        .badge {
            display: inline-block; padding: 5px 12px;
            background: linear-gradient(135deg, rgba(0, 255, 200, 0.3), rgba(255, 100, 100, 0.3));
            border-radius: 15px; font-size: 11px;
            margin-top: 10px; color: #fff;
            font-weight: bold; letter-spacing: 0.5px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls">
        <h1>‚≠ê Realistic v2.0</h1>
        
        <div class="mode-grid">
            <button class="mode-btn active" data-mode="snowflake">
                ‚ùÑÔ∏è<br><strong>Snowflake</strong><br><small>ÂÖ≠ËßíÈõ™Ëä±</small>
            </button>
            <button class="mode-btn" data-mode="firefly">
                ‚ú®<br><strong>Firefly</strong><br><small>Ëê§ÁÅ´Ëô´</small>
            </button>
            <button class="mode-btn" data-mode="smoke">
                üí®<br><strong>Smoke</strong><br><small>‰ΩìÁßØÁÉüÈõæ</small>
            </button>
            <button class="mode-btn" data-mode="flame">
                üî•<br><strong>Flame</strong><br><small>ÁÅ´ÁÑ∞ÁÉ≠Êµ™</small>
            </button>
            <button class="mode-btn" data-mode="firework">
                üéÜ<br><strong>Firework</strong><br><small>ÁàÜÁÇ∏ÁÉüËä±</small>
            </button>
        </div>
        
        <h2>‚öôÔ∏è Parameters</h2>
        
        <div class="control-group">
            <label>Color</label>
            <input type="color" id="color-picker" value="#e8f4ff">
        </div>
        
        <div class="control-group">
            <label>Count: <span id="count-value">18000</span></label>
            <input type="range" id="particle-count" min="5000" max="30000" value="18000" step="2500">
        </div>
        
        <div class="control-group">
            <label>Size: <span id="size-value">1.0</span></label>
            <input type="range" id="particle-size" min="0.4" max="3.5" value="1.0" step="0.1">
        </div>
        
        <div class="control-group">
            <label>Speed: <span id="speed-value">0.05</span></label>
            <input type="range" id="particle-speed" min="0.01" max="0.35" value="0.05" step="0.01">
        </div>
        
        <div class="control-group">
            <label>Intensity: <span id="intensity-value">2.0</span></label>
            <input type="range" id="intensity" min="0.5" max="4.0" value="2.0" step="0.1">
        </div>
        
        <button id="screenshot" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">
            üì∏ Screenshot
        </button>
        <button id="reset" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
            üîÑ Reset
        </button>
    </div>
    
    <div class="info">
        <div>üñ±Ô∏è <strong>Drag</strong> rotate</div>
        <div>üîç <strong>Scroll</strong> zoom</div>
        <div>‚ö° <strong>Spherical</strong> mode</div>
        <div class="badge">REALISTIC v2.0</div>
    </div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

console.log('üöÄ Realistic v2.0 Loading...');

const sharedVertex = `
attribute float size;
attribute float phase;
attribute float lifetime;
varying float vPhase;
varying float vLifetime;
varying vec3 vPosition;
uniform float time;
void main() {
    vPhase = phase;
    vLifetime = lifetime;
    vPosition = position;
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    gl_PointSize = size * (500.0 / -mvPosition.z);
    gl_Position = projectionMatrix * mvPosition;
}
`;

const snowflakeFragment = `
uniform vec3 color;
uniform float intensity;
uniform float time;
varying float vPhase;
varying vec3 vPosition;
#define PI 3.14159265359
float hexagonSDF(vec2 p, float r) {
    const vec3 k = vec3(-0.866025404, 0.5, 0.577350269);
    p = abs(p);
    p -= 2.0 * min(dot(k.xy, p), 0.0) * k.xy;
    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);
    return length(p) * sign(p.y);
}
float snowflakeShape(vec2 p) {
    float angle = atan(p.y, p.x);
    float r = length(p);
    float a6 = mod(angle, PI/3.0) - PI/6.0;
    vec2 p6 = vec2(cos(a6), sin(a6)) * r;
    float mainArm = 1.0 - smoothstep(0.02, 0.04, abs(p6.y));
    mainArm *= smoothstep(0.9, 0.85, r);
    float branch1 = 1.0 - smoothstep(0.01, 0.02, abs(p6.y - 0.15));
    branch1 *= smoothstep(0.7, 0.65, r) * smoothstep(0.3, 0.35, r);
    float hex = hexagonSDF(p, 0.15);
    float core = 1.0 - smoothstep(-0.02, 0.02, hex);
    return clamp(core + mainArm*0.9 + branch1*0.7, 0.0, 1.0);
}
vec3 prismEffect(vec3 base, float angle) {
    vec3 rainbow = vec3(
        sin(angle*3.0 + time*2.0)*0.5 + 0.5,
        sin(angle*3.0 + time*2.0 + 2.094)*0.5 + 0.5,
        sin(angle*3.0 + time*2.0 + 4.189)*0.5 + 0.5
    );
    return mix(base, rainbow*1.5, intensity*0.2);
}
void main() {
    vec2 uv = (gl_PointCoord - 0.5) * 2.0;
    float rotation = time*0.3 + vPhase*6.28;
    float c = cos(rotation);
    float s = sin(rotation);
    uv = mat2(c, -s, s, c) * uv;
    float shape = snowflakeShape(uv);
    float sparkle = sin(time*6.0 + vPhase*12.0)*0.4 + 0.6;
    sparkle = pow(sparkle, 3.0) * intensity;
    float angle = atan(uv.y, uv.x);
    vec3 finalColor = prismEffect(color, angle) * (1.0 + sparkle*0.3);
    float alpha = shape * (0.85 + sparkle*0.15);
    gl_FragColor = vec4(finalColor, alpha);
}
`;

const fireflyFragment = `
uniform vec3 color;
uniform float intensity;
uniform float time;
varying float vPhase;
varying vec3 vPosition;
void main() {
    vec2 uv = gl_PointCoord - 0.5;
    float d = length(uv)*2.0;
    float core = 1.0 - smoothstep(0.0, 0.3, d);
    float glow = 1.0 / (d*4.0 + 1.0);
    float pulse = sin(time*5.0 + vPhase*8.0)*0.5 + 0.5;
    pulse = pow(pulse, 2.0);
    float finalGlow = core*1.8 + glow*pulse*0.8;
    finalGlow *= intensity;
    vec3 finalColor = color * (1.0 + pulse*0.6);
    float alpha = finalGlow * (1.0 - smoothstep(0.6, 1.0, d));
    gl_FragColor = vec4(finalColor, alpha);
}
`;

const smokeFragment = `
uniform vec3 color;
uniform float intensity;
uniform float time;
varying float vPhase;
varying float vLifetime;
varying vec3 vPosition;
float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7)))*43758.5453); }
float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f*f*(3.0 - 2.0*f);
    return mix(mix(hash(i), hash(i+vec2(1,0)), f.x),
               mix(hash(i+vec2(0,1)), hash(i+vec2(1,1)), f.x), f.y);
}
float fbm(vec2 p) {
    float v = 0.0, a = 0.5;
    for(int i=0; i<4; i++) {
        v += a * noise(p);
        p *= 2.0;
        a *= 0.5;
    }
    return v;
}
void main() {
    vec2 uv = (gl_PointCoord - 0.5)*2.0;
    float dist = length(uv);
    vec2 nc = uv*3.0 + time*0.2 + vPhase*5.0;
    float n = fbm(nc);
    float turb = fbm(nc*2.0 + vec2(time*0.3, 0));
    dist += (n - 0.5)*0.3 + (turb - 0.5)*0.2;
    float alpha = 1.0 - smoothstep(0.0, 1.2, dist);
    alpha *= 0.4 + n*0.3;
    alpha *= vLifetime;
    vec3 smokeColor = color * (0.7 + n*0.6);
    smokeColor = mix(smokeColor, vec3(1.0), n*0.2*intensity);
    gl_FragColor = vec4(smokeColor, alpha*intensity*0.6);
}
`;

const flameFragment = `
uniform vec3 color;
uniform float intensity;
uniform float time;
varying float vPhase;
varying float vLifetime;
varying vec3 vPosition;
float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7)))*43758.5453); }
float noise(vec2 p) {
    vec2 i = floor(p), f = fract(p);
    f = f*f*(3.0 - 2.0*f);
    return mix(mix(hash(i), hash(i+vec2(1,0)), f.x),
               mix(hash(i+vec2(0,1)), hash(i+vec2(1,1)), f.x), f.y);
}
void main() {
    vec2 uv = (gl_PointCoord - 0.5)*2.0;
    float dist = length(uv);
    float flicker = noise(uv*4.0 + time*8.0 + vPhase*10.0)*0.4;
    dist += flicker - 0.2;
    float flame = 1.0 - smoothstep(0.0, 1.0, dist);
    flame *= vLifetime;
    vec3 orange = vec3(1.0, 0.4, 0.1);
    vec3 yellow = vec3(1.0, 0.9, 0.3);
    vec3 white = vec3(1.2, 1.2, 1.0);
    vec3 flameColor;
    if(dist < 0.3) flameColor = mix(white, yellow, dist/0.3);
    else if(dist < 0.7) flameColor = mix(yellow, orange, (dist-0.3)/0.4);
    else flameColor = mix(orange, color, (dist-0.7)/0.3);
    flameColor *= 1.0 + intensity*0.5;
    gl_FragColor = vec4(flameColor, flame*0.9);
}
`;

const fireworkFragment = `
uniform vec3 color;
uniform float intensity;
uniform float time;
varying float vPhase;
varying float vLifetime;
varying vec3 vPosition;
void main() {
    vec2 uv = (gl_PointCoord - 0.5)*2.0;
    float dist = length(uv);
    float trail = 1.0/(dist*6.0 + 1.0);
    float pulse = sin(time*12.0 + vPhase*20.0)*0.5 + 0.5;
    pulse = pow(pulse, 2.0);
    vec3 startColor = color;
    vec3 endColor = color*0.3;
    vec3 finalColor = mix(endColor, startColor, vLifetime);
    finalColor *= intensity*(1.0 + pulse*0.5);
    float alpha = trail*(1.0 - dist)*vLifetime;
    gl_FragColor = vec4(finalColor, alpha);
}
`;

const configs = {
    snowflake: { type:'snowflake', count:18000, color:'#e8f4ff', size:1.0, speed:0.05, intensity:2.0, shader:'snowflake' },
    firefly: { type:'firefly', count:5000, color:'#ffee88', size:1.8, speed:0.04, intensity:2.5, shader:'firefly' },
    smoke: { type:'smoke', count:12000, color:'#a0b0c0', size:1.5, speed:0.03, intensity:1.8, shader:'smoke' },
    flame: { type:'flame', count:10000, color:'#ff6600', size:1.4, speed:0.08, intensity:2.8, shader:'flame' },
    firework: { type:'firework', count:8000, color:'#ff55ff', size:1.2, speed:0.15, intensity:3.0, shader:'firework' }
};

let scene, camera, renderer, controls, particles=null, backgroundStars=null;
let currentConfig = {...configs.snowflake};
let time = 0;

function randomPointInSphere(radius) {
    const u = Math.random(), v = Math.random();
    const theta = 2*Math.PI*u;
    const phi = Math.acos(2*v - 1);
    const r = radius * Math.cbrt(Math.random());
    const sinPhi = Math.sin(phi);
    return [r*sinPhi*Math.cos(theta), r*sinPhi*Math.sin(theta), r*Math.cos(phi)];
}

function init() {
    scene = new THREE.Scene();
    createCosmicBackground();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 8, 30);
    renderer = new THREE.WebGLRenderer({antialias:true, alpha:false, powerPreference:'high-performance'});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.getElementById('canvas-container').appendChild(renderer.domElement);
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 15;
    controls.maxDistance = 70;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1.2;
    controls.maxPolarAngle = Math.PI*0.65;
    scene.add(new THREE.AmbientLight(0xffffff, 2.0));
    const l1 = new THREE.PointLight(0x00ffaa, 3.5, 120);
    l1.position.set(25,25,25);
    scene.add(l1);
    const l2 = new THREE.PointLight(0x0088ff, 3.0, 120);
    l2.position.set(-25,-20,20);
    scene.add(l2);
    createParticles();
    setupControls();
    window.addEventListener('resize', ()=>{
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    animate();
    console.log('‚úÖ v2.0 Ready!');
}

function createCosmicBackground() {
    const canvas = document.createElement('canvas');
    canvas.width=4; canvas.height=512;
    const ctx = canvas.getContext('2d');
    const g = ctx.createLinearGradient(0,0,0,512);
    g.addColorStop(0,'#000820');
    g.addColorStop(0.4,'#001a40');
    g.addColorStop(0.7,'#002855');
    g.addColorStop(1,'#000');
    ctx.fillStyle=g;
    ctx.fillRect(0,0,4,512);
    scene.background = new THREE.CanvasTexture(canvas);
    const starGeo = new THREE.BufferGeometry();
    const starCount = 8000;
    const starPos = new Float32Array(starCount*3);
    for(let i=0; i<starCount; i++) {
        const i3=i*3;
        const rad = 200 + Math.random()*500;
        const theta = Math.random()*Math.PI*2;
        const phi = Math.acos(Math.random()*2 - 1);
        starPos[i3] = rad*Math.sin(phi)*Math.cos(theta);
        starPos[i3+1] = rad*Math.sin(phi)*Math.sin(theta);
        starPos[i3+2] = rad*Math.cos(phi);
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos,3));
    const starMat = new THREE.PointsMaterial({color:0xffffff, size:1.5, sizeAttenuation:true, transparent:true, opacity:1.0, blending:THREE.AdditiveBlending});
    backgroundStars = new THREE.Points(starGeo, starMat);
    scene.add(backgroundStars);
}

function createParticles() {
    if(particles) {
        scene.remove(particles);
        particles.geometry.dispose();
        particles.material.dispose();
    }
    const count = currentConfig.count;
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count*3);
    const vel = new Float32Array(count*3);
    const phases = new Float32Array(count);
    const sizes = new Float32Array(count);
    const lifetimes = new Float32Array(count);
    const radius = 18;
    for(let i=0; i<count; i++) {
        const i3=i*3;
        const p = randomPointInSphere(radius);
        pos[i3]=p[0]; pos[i3+1]=p[1]; pos[i3+2]=p[2];
        if(currentConfig.type==='firework') {
            const len = Math.sqrt(p[0]*p[0]+p[1]*p[1]+p[2]*p[2])||1;
            vel[i3] = p[0]/len*0.3;
            vel[i3+1] = p[1]/len*0.3;
            vel[i3+2] = p[2]/len*0.3;
        } else {
            vel[i3] = (Math.random()-0.5)*0.2;
            vel[i3+1] = (Math.random()-0.5)*0.2;
            vel[i3+2] = (Math.random()-0.5)*0.2;
        }
        phases[i] = Math.random()*Math.PI*2;
        sizes[i] = (Math.random()*0.6+0.7)*currentConfig.size;
        lifetimes[i] = Math.random();
    }
    geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    geo.setAttribute('velocity', new THREE.BufferAttribute(vel,3));
    geo.setAttribute('phase', new THREE.BufferAttribute(phases,1));
    geo.setAttribute('size', new THREE.BufferAttribute(sizes,1));
    geo.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes,1));
    let frag;
    switch(currentConfig.shader) {
        case 'snowflake': frag=snowflakeFragment; break;
        case 'firefly': frag=fireflyFragment; break;
        case 'smoke': frag=smokeFragment; break;
        case 'flame': frag=flameFragment; break;
        case 'firework': frag=fireworkFragment; break;
    }
    const mat = new THREE.ShaderMaterial({
        uniforms: {
            color: {value: new THREE.Color(currentConfig.color)},
            time: {value:0},
            intensity: {value:currentConfig.intensity}
        },
        vertexShader: sharedVertex,
        fragmentShader: frag,
        transparent: true,
        blending: currentConfig.shader==='smoke'? THREE.NormalBlending : THREE.AdditiveBlending,
        depthWrite: false
    });
    particles = new THREE.Points(geo, mat);
    scene.add(particles);
    console.log(`‚úÖ ${count} ${currentConfig.type}`);
}

function updateParticles() {
    if(!particles) return;
    time += 0.016;
    particles.material.uniforms.time.value = time;
    particles.material.uniforms.intensity.value = currentConfig.intensity;
    const pos = particles.geometry.attributes.position.array;
    const vel = particles.geometry.attributes.velocity.array;
    const phases = particles.geometry.attributes.phase.array;
    const lifetimes = particles.geometry.attributes.lifetime.array;
    const speed = currentConfig.speed;
    const radius = 18;
    for(let i=0; i<pos.length; i+=3) {
        const idx=i/3;
        const phase=phases[idx];
        const px=pos[i], py=pos[i+1], pz=pos[i+2];
        const r = Math.sqrt(px*px+py*py+pz*pz);
        switch(currentConfig.type) {
            case 'snowflake':
                pos[i+1] -= speed*1.5;
                pos[i] += Math.sin(time+phase)*0.01;
                pos[i+2] += Math.cos(time+phase)*0.01;
                if(pos[i+1]<-radius) {
                    pos[i+1]=radius;
                    const np = randomPointInSphere(radius*0.8);
                    pos[i]=np[0]; pos[i+2]=np[2];
                }
                break;
            case 'firefly':
                const drift = Math.sin(time*0.7+phase)*0.02;
                const wave = Math.sin(time*2.0+phase*1.3)*0.03;
                pos[i] += vel[i]*speed*0.5 + drift;
                pos[i+1] += vel[i+1]*speed*0.2 + wave;
                pos[i+2] += vel[i+2]*speed*0.5 + Math.cos(time*0.5+phase*1.7)*0.02;
                if(r>radius) {
                    const k=radius/r;
                    pos[i]=px*k; pos[i+1]=py*k; pos[i+2]=pz*k;
                }
                break;
            case 'smoke':
                pos[i+1] += speed;
                pos[i] += Math.sin(time*0.5+phase)*0.02;
                pos[i+2] += Math.cos(time*0.5+phase)*0.015;
                lifetimes[idx] = Math.max(0, lifetimes[idx]-0.003);
                if(lifetimes[idx]<=0 || pos[i+1]>radius) {
                    pos[i+1]=-radius;
                    const np = randomPointInSphere(radius*0.5);
                    pos[i]=np[0]; pos[i+2]=np[2];
                    lifetimes[idx]=1.0;
                }
                break;
            case 'flame':
                pos[i+1] += speed*2;
                pos[i] += Math.sin(time*2+phase)*0.08;
                pos[i+2] += Math.cos(time*1.5+phase)*0.06;
                lifetimes[idx] = Math.max(0, lifetimes[idx]-0.005);
                if(lifetimes[idx]<=0 || pos[i+1]>radius) {
                    pos[i+1]=-radius;
                    const np = randomPointInSphere(radius*0.3);
                    pos[i]=np[0]; pos[i+2]=np[2];
                    lifetimes[idx]=1.0;
                }
                break;
            case 'firework':
                pos[i] += vel[i]*speed*3;
                pos[i+1] += vel[i+1]*speed*3 - 0.01;
                pos[i+2] += vel[i+2]*speed*3;
                lifetimes[idx] = Math.max(0, lifetimes[idx]-0.008);
                if(lifetimes[idx]<=0 || r>radius*1.2) {
                    const np = randomPointInSphere(2);
                    pos[i]=np[0]; pos[i+1]=np[1]; pos[i+2]=np[2];
                    const len = Math.sqrt(pos[i]*pos[i]+pos[i+1]*pos[i+1]+pos[i+2]*pos[i+2])||1;
                    vel[i]=(Math.random()-0.5)*0.3;
                    vel[i+1]=(Math.random()-0.5)*0.3;
                    vel[i+2]=(Math.random()-0.5)*0.3;
                    lifetimes[idx]=1.0;
                }
                break;
        }
    }
    particles.geometry.attributes.position.needsUpdate=true;
    if(['smoke','flame','firework'].includes(currentConfig.type)) {
        particles.geometry.attributes.lifetime.needsUpdate=true;
    }
    if(backgroundStars) backgroundStars.rotation.y+=0.0004;
}

function setupControls() {
    const btns = document.querySelectorAll('.mode-btn');
    btns.forEach(btn=>{
        btn.addEventListener('click',()=>{
            btns.forEach(b=>b.classList.remove('active'));
            btn.classList.add('active');
            const mode = btn.dataset.mode;
            currentConfig = {...configs[mode]};
            document.getElementById('color-picker').value=currentConfig.color;
            document.getElementById('particle-count').value=currentConfig.count;
            document.getElementById('particle-size').value=currentConfig.size;
            document.getElementById('particle-speed').value=currentConfig.speed;
            document.getElementById('intensity').value=currentConfig.intensity;
            document.getElementById('count-value').textContent=currentConfig.count;
            document.getElementById('size-value').textContent=currentConfig.size;
            document.getElementById('speed-value').textContent=currentConfig.speed;
            document.getElementById('intensity-value').textContent=currentConfig.intensity;
            createParticles();
        });
    });
    document.getElementById('color-picker').addEventListener('input',(e)=>{
        currentConfig.color=e.target.value;
        particles.material.uniforms.color.value=new THREE.Color(e.target.value);
    });
    document.getElementById('particle-count').addEventListener('input',(e)=>{
        const v=parseInt(e.target.value);
        document.getElementById('count-value').textContent=v;
        currentConfig.count=v;
        createParticles();
    });
    document.getElementById('particle-size').addEventListener('input',(e)=>{
        document.getElementById('size-value').textContent=e.target.value;
        currentConfig.size=parseFloat(e.target.value);
    });
    document.getElementById('particle-speed').addEventListener('input',(e)=>{
        document.getElementById('speed-value').textContent=e.target.value;
        currentConfig.speed=parseFloat(e.target.value);
    });
    document.getElementById('intensity').addEventListener('input',(e)=>{
        document.getElementById('intensity-value').textContent=e.target.value;
        currentConfig.intensity=parseFloat(e.target.value);
    });
    document.getElementById('screenshot').addEventListener('click',()=>{
        renderer.render(scene,camera);
        renderer.domElement.toBlob((blob)=>{
            const url=URL.createObjectURL(blob);
            const link=document.createElement('a');
            link.href=url;
            link.download=`realistic-${currentConfig.type}-${Date.now()}.png`;
            link.click();
            URL.revokeObjectURL(url);
        });
    });
    document.getElementById('reset').addEventListener('click',()=>{
        camera.position.set(0,8,30);
        controls.target.set(0,0,0);
        controls.update();
    });
}

function animate() {
    requestAnimationFrame(animate);
    controls.update();
    updateParticles();
    renderer.render(scene,camera);
}

init();
console.log('üéâ v2.0: 5 Effects Active!');
    </script>
</body>
</html>